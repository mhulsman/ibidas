

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Basic concepts &mdash; Ibidas v0.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Ibidas v0.1 documentation" href="index.html" />
    <link rel="next" title="Module reference" href="ibidas_module.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ibidas_module.html" title="Module reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Ibidas v0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="basic-concepts">
<h1>Basic concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This section is a bit outdated, please use the tutorial.</p>
</div>
<p>In this section we describe some of the basic underlying concepts of Ibidas.</p>
<div class="section" id="representation">
<h2>Representation<a class="headerlink" href="#representation" title="Permalink to this headline">¶</a></h2>
<p>In Ibidas one works with data sources by packaging them within a &#8216;representation object&#8217;.</p>
<p>Such data sources can be python objects, files, databases, and so on.
Once they are wihtin a representation object they are all handled similarly.</p>
<p>We start with a simple example, in which we package an integer object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Slices: data</span>
<span class="go">Types:  int64</span>
<span class="go">Dims:</span>

<span class="go">Data: 3</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The concepts <tt class="docutils literal"><span class="pre">slices</span></tt>, <tt class="docutils literal"><span class="pre">types</span></tt> and <tt class="docutils literal"><span class="pre">dims</span></tt> will be explained in the next sections</p>
</div>
<p>One can perform all kind of operations with data that is in a representation object, e.g:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rep</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="mi">3</span>
<span class="go">Slices: data</span>
<span class="go">Types:  int64</span>
<span class="go">Dims:   d1:3</span>

<span class="go">Data: [4 5 6]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Summary:</dt>
<dd><ul class="first last simple">
<li>A representor object encapsulates a data source.</li>
<li>Data sources can be python objects, but also files or databases.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="lazy-execution">
<h2>Lazy execution<a class="headerlink" href="#lazy-execution" title="Permalink to this headline">¶</a></h2>
<p>You might have noted that executing the previous commands resulted immediatly in a printout
of the contents of the representation object. This is due to the IPython interpreter,
which will print a representation of the result of all non-assignment operations.
So, if we instead would have executed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">rep</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="mi">3</span>
</pre></div>
</div>
<p>no output would have been printed. More importantly however, Ibidas would also not have performed the
requested addition operation. I.e. <tt class="docutils literal"><span class="pre">r</span></tt> would have only been a representation of the requested operations
and data sources, and thus not the result of those operations.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Operations are executed lazily. I.e. only when output is requested by the user.</p>
</div>
<p>The reason for this behaviour is that it allows optimizations which are otherwise not possible. For example, it
enables the system to translate queries against a database (partially) into the query language SQL. This way,
instead of moving unnecessary data to Ibidas, operations can be moved to the database.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For brevity, we will sometimes print output in this tutorial after assignments (e.g. <tt class="docutils literal"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">rep(3)</span></tt>.
In reality this does not happen. One can still get the output after such statements, by simply execting <tt class="docutils literal"><span class="pre">r</span></tt></p>
</div>
<p>Often, one wants to just see a description of the contents of a representation object, not the actual data result itself.
This can be done using the information attribute <tt class="docutils literal"><span class="pre">I</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">rep</span><span class="p">([</span><span class="s">&quot;geneA&quot;</span><span class="p">,</span><span class="s">&quot;geneB&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">I</span>
<span class="go">Slices: data</span>
<span class="go">Types:  bytes[5]</span>
<span class="go">Dims:   d1:2</span>
</pre></div>
</div>
<p>Note that the data is not printed. Especially in case of slow operations or data sources this can be useful.</p>
<p>Getting data out of a representor object is simple, one simply appends <tt class="docutils literal"><span class="pre">()</span></tt> to a query to let it return the
results as normal <tt class="docutils literal"><span class="pre">numpy</span></tt> or python objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()</span>
<span class="go">array([&#39;geneA&#39;, &#39;geneB&#39;], dtype=&#39;|S5&#39;)</span>
</pre></div>
</div>
<p>As you can see, Ibidas has packaged the data in a numpy array.</p>
<dl class="docutils">
<dt>Summary:</dt>
<dd><ul class="first last simple">
<li>Operations are only executed when needed, to allow for optimizations</li>
<li>One can ask for a description of the representor contents using the <tt class="docutils literal"><span class="pre">I</span></tt> attribute.</li>
<li>One can get the data results by transforming the query into a function call by appending <tt class="docutils literal"><span class="pre">()</span></tt></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="types">
<h2>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h2>
<p>When one executes <tt class="docutils literal"><span class="pre">rep</span></tt> without specifying a type, the type is detected automatically.
For example, in the first example, the detect type was <tt class="docutils literal"><span class="pre">int64</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Depending on the platform you use, the type can also be <tt class="docutils literal"><span class="pre">int32</span></tt>.</p>
</div>
<p>The type determines how operations on the representor are handled.
For example, with an integer type, one can perform standard integer operations on the representor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">rep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span>
<span class="go">Slices: data</span>
<span class="go">Types:  int32</span>
<span class="go">Dims:</span>

<span class="go">Data: 18</span>
</pre></div>
</div>
<p>Similarly, in case of the string type, the addition operation becomes concatenation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rep</span><span class="p">([</span><span class="s">&quot;geneA&quot;</span><span class="p">,</span> <span class="s">&quot;geneB&quot;</span><span class="p">])</span>  <span class="o">+</span> <span class="s">&quot;_geneC&quot;</span>
<span class="go">Slices: data</span>
<span class="go">Types:  bytes[11]</span>
<span class="go">Dims:   d1:2</span>

<span class="go">Data: [&#39;geneA_geneC&#39; &#39;geneB_geneC&#39;]</span>
</pre></div>
</div>
<p>One might have noted that, although we now represent a list of thins, the type still represents the
type of the list elements.</p>
<p>This is because <tt class="docutils literal"><span class="pre">rep</span></tt> (by default) <strong>unpacks</strong> the data. By unpacking, operations
will not be performed at the <em>list</em> level, but instead at the <em>list elements</em> level. Unpacking/packing will be explained
further in one of the next sections.</p>
<dl class="docutils">
<dt>Summary:</dt>
<dd><ul class="first last simple">
<li>A type is assigned automatically when packaging data using <tt class="docutils literal"><span class="pre">rep</span></tt></li>
<li>The type indicates at which data nesting level operations are executed.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="slices">
<h2>Slices<a class="headerlink" href="#slices" title="Permalink to this headline">¶</a></h2>
<p>Whereas lists in Ibidas are used to denote collections of data with the same type,
tuples are used to describe data compositions of different types.</p>
<p>You might have know such compositions as <em>records</em>, or simply as table rows.</p>
<p>So, lets load a simple table:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;gene1&#39;</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;gene2&#39;</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;gene3&#39;</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">rep</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Slices: f0       f1</span>
<span class="go">Types:  bytes[5] real64</span>
<span class="go">Dims:   d1:3     .</span>

<span class="go">Data: (array([&#39;gene1&#39;, &#39;gene2&#39;, &#39;gene3&#39;],</span>
<span class="go">    dtype=&#39;|S5&#39;), array([ 0.5,  0.3,  0.8]))</span>
</pre></div>
</div>
<p>If we compare this to earlier output, we now see that there are more than one columns in the data description.</p>
<p>These columns represented <em>slices</em>. Slices are one of the main concepts in Ibidas. They can be compared to columns/fields in a table, but are more general.</p>
<p>Selecting a slice can be done using simple attribute lookup:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">f0</span>
<span class="go">Slices: f0</span>
<span class="go">Types:  bytes[5]</span>
<span class="go">Dims:   d1:3</span>

<span class="go">Data: [&#39;gene1&#39; &#39;gene2&#39; &#39;gene3&#39;]</span>
</pre></div>
</div>
<p>Each slice has a name (the first row), a type (second row) and a dimension (third row). Dimensions will be explained later. For now, it is important that each
slice has a common type. This means that all data elements adressed by it can be handled in the same way. Slices could thus also be seen as a kind of cursor in your data structure.
Performing operations on this cursor will perform the operations on a subset of your data. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">f0</span> <span class="o">==</span> <span class="s">&quot;gene2&quot;</span>
<span class="go">Slices: f0</span>
<span class="go">Types:  bool</span>
<span class="go">Dims:   d1:3</span>

<span class="go">Data: [False  True False]</span>
</pre></div>
</div>
<p>To select multiple slices, one can use the <tt class="xref py py-meth docutils literal"><span class="pre">ibidas.representor.Representor.get()</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;f1&quot;</span><span class="p">,</span> <span class="s">&quot;f0&quot;</span><span class="p">)</span>
<span class="go">Slices: f1     f0</span>
<span class="go">Types:  real64 bytes[5]</span>
<span class="go">Dims:   d1:3   .</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">Slices: f1     f0</span>
<span class="go">Types:  real64 bytes[5]</span>
<span class="go">Dims:   d1:3   .</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">f1</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
<span class="go">Slices: f1     f0</span>
<span class="go">Types:  real64 bytes[5]</span>
<span class="go">Dims:   d1:3   .</span>
</pre></div>
</div>
<p>As you can see, there are multiple options to address slices.  The third option is useful, as this can also be combined with other operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">f1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
<span class="go">Slices: f1     f0</span>
<span class="go">Types:  real64 bytes[5]</span>
<span class="go">Dims:   d1:3   .</span>

<span class="go">Data: (array([ 3.5,  3.3,  3.8]), array([&#39;gene1&#39;, &#39;gene2&#39;, &#39;gene3&#39;],</span>
<span class="go">    dtype=&#39;|S5&#39;))</span>
</pre></div>
</div>
<p>One can also use this function to combine slices, e.g:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">f0</span><span class="p">,</span> <span class="n">rep</span><span class="p">(</span><span class="s">&quot;cancer_genes&quot;</span><span class="p">))</span>
<span class="go">Slices: f0       data</span>
<span class="go">Types:  bytes[5] bytes[12]</span>
<span class="go">Dims:   d1:3</span>

<span class="go">Data: (array([&#39;gene1&#39;, &#39;gene2&#39;, &#39;gene3&#39;],</span>
<span class="go">    dtype=&#39;|S5&#39;), &#39;cancer_genes&#39;)</span>
</pre></div>
</div>
<p>When loading data from databases or files, often slice names are assigned as given in the data source. In case of loading from Python data,
slice names are however autoassigned, and thus not very informative. To rename slices, one can use the <tt class="xref py py-meth docutils literal"><span class="pre">ibidas.representor.Representor.rename()</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;genes&quot;</span><span class="p">,</span><span class="s">&quot;scores&quot;</span><span class="p">)</span>
<span class="go">Slices: genes    scores</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">f1</span><span class="o">=</span><span class="s">&quot;scores&quot;</span><span class="p">)</span>
<span class="go">Slices: f0    scores</span>
</pre></div>
</div>
<p>As this functionality is used often, a shorter version is available:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">/</span><span class="p">(</span><span class="s">&quot;genes&quot;</span><span class="p">,</span><span class="s">&quot;scores&quot;</span><span class="p">)</span>
<span class="go">Slices: genes    scores</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">/</span><span class="p">{</span><span class="n">f1</span><span class="p">:</span><span class="s">&quot;scores&quot;</span><span class="p">}</span>
<span class="go">Slices: f0    scores</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">f0</span><span class="o">/</span><span class="s">&quot;genes&quot;</span><span class="p">,</span>
<span class="go">          rep(&quot;cancer_genes&quot;)/&quot;listname&quot;)</span>
<span class="go">Slices: genes       listname</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Summary:</dt>
<dd><ul class="first last simple">
<li>Slices can be compared to columns/fields in a table, or to data cursors which indicate on which data elements operations will be applied.</li>
<li>A representor object is a collection of slices</li>
<li>Attribute lookup can be used to select a single slice.</li>
<li>More advanced selection can be performed using the <tt class="docutils literal"><span class="pre">get</span></tt> function, allowing multiple slice selection, slice modifications and slice combination.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="dimensions">
<h2>Dimensions<a class="headerlink" href="#dimensions" title="Permalink to this headline">¶</a></h2>
<p>Up to now, our data model was very similar to ones used in other software. <em>Dimensions</em> allow Ibidas to handle more complex data structures.</p>
<dl class="docutils">
<dt>Lets replace the first field of the table with a nested, variable length list::</dt>
<dd><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mf">0.5</span><span class="p">),</span> <span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mf">0.3</span><span class="p">),</span> <span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="mf">0.8</span><span class="p">)]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">rep</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Slices: f0        f1</span>
<span class="go">Types:  int32     real64</span>
<span class="go">Dims:   d1:3&lt;d2:~ .</span>
</pre></div>
</div>
<p class="last">Data: (array([[1 2], [3 4 5], [6 7 8 9]], dtype=object), array([ 0.5,  0.3,  0.8]))</p>
</dd>
</dl>
<p>Compare this to dims in the previous sections. Dimensions indicate which nesting arrays have been <strong>unpacked</strong>. So, in case of slice <tt class="docutils literal"><span class="pre">f0</span></tt>,
we are working at the level of <tt class="docutils literal"><span class="pre">int32</span></tt> (the type). These <tt class="docutils literal"><span class="pre">int32</span></tt> elements are nested two levels deep in arrays, which are indicated by
dimension <tt class="docutils literal"><span class="pre">d1</span></tt> and <tt class="docutils literal"><span class="pre">d2</span></tt>.</p>
<p>The dim names are accompanied by a shape attribute. The <tt class="docutils literal"><span class="pre">3</span></tt> means that the dimension has a fixed size of 3, while the <tt class="docutils literal"><span class="pre">~</span></tt> means that the
dimension has a variable size. One might also encounter <tt class="docutils literal"><span class="pre">*</span></tt>, which means that the dimension has a fixed, but unspecified, size.</p>
<p>So what does the <tt class="docutils literal"><span class="pre">.</span></tt> mean in the dimension of slice <tt class="docutils literal"><span class="pre">f1</span></tt>? In case of large tables with many slices and long dimension names, it can be a bit
unwieldy to repeat the same dimensions for every slice. Therefore, we use a shorthand. The <tt class="docutils literal"><span class="pre">.</span></tt> here means that it has the same first dimension as the
previous slice.  If it would be <tt class="docutils literal"><span class="pre">.&lt;.</span></tt>, it would mean that it shares the first two dimensions, and so on.</p>
<p>Dimensions are used in operations to determine how data is mapped w.r.t to each other:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">f0</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">f1</span>
<span class="go">Slices: result</span>
<span class="go">Types:  real64</span>
<span class="go">Dims:   d1:3&lt;d2:~</span>

<span class="go">Data: [[ 1.5  2.5] [ 3.3  4.3  5.3] [ 6.8  7.8  8.8  9.8]]</span>
</pre></div>
</div>
<p>To perform an addition, both operands would need the same dimension normally. As this is not the case,
we perform <strong>broadcasting</strong>. As you can see, elements from slice <tt class="docutils literal"><span class="pre">f1</span></tt>  are broadcasted along dimension <tt class="docutils literal"><span class="pre">d2</span></tt> to enable
the addition of the two slices.</p>
<p>In case of type autodetection, dimension names are also assigned automatically (Starting from <tt class="docutils literal"><span class="pre">d1</span></tt>). Dimension can however
be renamed in a similar way as slices, using <tt class="xref py py-meth docutils literal"><span class="pre">ibidas.representor.Representor.dim_rename()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">dim_rename</span><span class="p">(</span><span class="s">&quot;pathways&quot;</span><span class="p">,</span><span class="s">&quot;genes&quot;</span><span class="p">)</span>
<span class="go">Slices: f0                 f1</span>
<span class="go">Types:  int32              real64</span>
<span class="go">Dims:   pathways:3&lt;genes:~ .</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">dim_renmae</span><span class="p">(</span><span class="n">d1</span><span class="o">=</span><span class="s">&quot;pathways&quot;</span><span class="p">)</span>
<span class="go">Dims:   pathways:3&lt;d2:~ .</span>
</pre></div>
</div>
<p>When performed without keywords, new dim names are mapped to dimensions by ordering dimensions on their nesting depth. If there are multiple
choices possible, an error will be returned. Similar to slice renaming, a shorthand is available using the <tt class="docutils literal"><span class="pre">%</span></tt> symbol.</p>
<p>Summary:</p>
<blockquote>
<ul class="simple">
<li>The use of dimensions allow one to have slices with different dimensions within the same representor object</li>
<li>The use of broadcasting allows these slices to still interact (e.g. to perform a comparison or other operation)</li>
<li>Dimensions have a name and a shape</li>
<li>The printout of a representor uses <tt class="docutils literal"><span class="pre">.</span></tt> to indicate a common dimension w.r.t to the previous slice.</li>
<li>Dimensions are separated by the <tt class="docutils literal"><span class="pre">&lt;</span></tt> symbol</li>
<li>Dimensions can be renamed using the dim_rename function or the <tt class="docutils literal"><span class="pre">%</span></tt> shorthand operation.</li>
</ul>
</blockquote>
</div>
<div class="section" id="packing-unpacking">
<h2>Packing/unpacking<a class="headerlink" href="#packing-unpacking" title="Permalink to this headline">¶</a></h2>
<p>Navigating accross dimensions and slices can be performed with <tt class="docutils literal"><span class="pre">pack</span></tt> and <tt class="docutils literal"><span class="pre">unpack</span></tt> operations.
There are two types of these operations:</p>
<blockquote>
<ul class="simple">
<li>pack/unpack from tuple type to slices and vice versa</li>
<li>pack/unpack from array type to dimensions and vice versa</li>
</ul>
</blockquote>
<div class="section" id="packing">
<h3>Packing<a class="headerlink" href="#packing" title="Permalink to this headline">¶</a></h3>
<p>The two most basic <tt class="docutils literal"><span class="pre">pack</span></tt> operations are respectively <tt class="docutils literal"><span class="pre">tuple</span></tt> and <tt class="docutils literal"><span class="pre">array</span></tt>.</p>
<p>An example of the <tt class="docutils literal"><span class="pre">array</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mf">0.5</span><span class="p">),</span> <span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mf">0.3</span><span class="p">),</span> <span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="mf">0.8</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">rep</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="go">Slices: f0           f1</span>
<span class="go">Types:  [d2:~]:int32 [d1:3]:real64</span>
<span class="go">Dims:   d1:3</span>

<span class="go">Data: (array([[1 2], [3 4 5], [6 7 8 9]], dtype=object), array([ 0.5,  0.3,  0.8]))</span>
</pre></div>
</div>
<p>The influence of the array operation is that the dimensions are moved into the type. So subsequent operations
are performed at the level of the arrays.</p>
<p>Arrays can also be packed with other aggregate operations. For example, the <tt class="docutils literal"><span class="pre">set</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">f0</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</pre></div>
</div>
<p>Performing the <tt class="docutils literal"><span class="pre">tuple</span></tt> operation gives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">tuple</span><span class="p">()</span>
<span class="go">Slices: data</span>
<span class="go">Types:  (f0=[d2:~]:int32, f1=real64)</span>
<span class="go">Dims:   d1:3</span>

<span class="go">Data: [(array([1, 2]), 0.5) (array([3, 4, 5]), 0.29999999999999999)</span>
<span class="go">(array([6, 7, 8, 9]), 0.80000000000000004)]</span>
</pre></div>
</div>
<p>As you can see, slice types are combined into a single slice tuple type.</p>
</div>
<div class="section" id="unpacking">
<h3>Unpacking<a class="headerlink" href="#unpacking" title="Permalink to this headline">¶</a></h3>
<p>The reverse operations for <tt class="docutils literal"><span class="pre">array</span></tt> and <tt class="docutils literal"><span class="pre">tuple</span></tt> are respectively <tt class="docutils literal"><span class="pre">elements</span></tt> and <tt class="docutils literal"><span class="pre">attributes</span></tt>.</p>
<p>These are used less commonly as by default dat is unpacked by representation.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Basic concepts</a><ul>
<li><a class="reference internal" href="#representation">Representation</a></li>
<li><a class="reference internal" href="#lazy-execution">Lazy execution</a></li>
<li><a class="reference internal" href="#types">Types</a></li>
<li><a class="reference internal" href="#slices">Slices</a></li>
<li><a class="reference internal" href="#dimensions">Dimensions</a></li>
<li><a class="reference internal" href="#packing-unpacking">Packing/unpacking</a><ul>
<li><a class="reference internal" href="#packing">Packing</a></li>
<li><a class="reference internal" href="#unpacking">Unpacking</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial.html"
                        title="previous chapter">Tutorial</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ibidas_module.html"
                        title="next chapter">Module reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/basic_concepts.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ibidas_module.html" title="Module reference"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">Ibidas v0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Marc Hulsman &amp; Jan Bot.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.5.
    </div>
  </body>
</html>